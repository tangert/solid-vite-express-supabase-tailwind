import { Accessor, Setter, Signal } from 'solid-js';
import { PageEvent } from 'solid-start';
import { Store, SetStoreFunction } from 'solid-js/store';

type StorageWithOptions<O> = {
    clear: (options?: O) => void;
    getItem: (key: string, options?: O) => string | null;
    getAll?: (options?: O) => {
        [key: string]: any;
    };
    setItem: (key: string, value: string, options?: O) => void;
    removeItem: (key: string, options?: O) => void;
    key: (index: number, options?: O) => string | null;
    getLength?: (options?: O) => number | undefined;
    readonly length: number | undefined;
    [key: string]: any;
};
type StorageDeserializer<T, O> = (value: string, key: string, options?: O) => T;
type StorageSerializer<T, O> = (value: T, key: string, options?: O) => string;
type AnyStorageProps<A, O, T> = {
    /** a Storage-like API, e.g. localStorage */
    api?: A | A[];
    /** a function that parses the stored data after retrieval */
    deserializer?: StorageDeserializer<T, O>;
    /** a function that serializes the data before storing */
    serializer?: StorageSerializer<T, O>;
    /** options for the Storage-like API, if supported */
    options?: O;
    /** a prefix for the keys */
    prefix?: string;
    /** should the storage be synchronized via Storage events, default is `true`? */
    sync?: boolean;
    /** errors will be thrown and need to be caught in an ErrorBoundary, default is `false` */
    throw?: boolean;
};
type StringStorageProps<A, O, T = string> = AnyStorageProps<A, O, T>;
type StorageProps<T, A, O> = T extends string ? StringStorageProps<A, O> : AnyStorageProps<A, O, T>;
type StorageObject<T> = Record<string, T>;
type StorageSetter<T, O> = (key: string, value: T, options?: O) => void;
type StorageActions<T> = {
    remove: (key: string) => void;
    clear: () => void;
    error: () => Error | undefined;
    toJSON: () => {
        [key: string]: T;
    };
};
type AsyncStorage = {
    clear?: () => Promise<void> | void;
    getItem: (key: string) => Promise<string | null> | string | null;
    getAll?: () => Promise<any>;
    setItem: (key: string, value: string) => Promise<void> | void;
    removeItem: (key: string) => Promise<void> | void;
    key: (index: number) => Promise<string | null> | string | null;
    readonly length: Promise<number> | number | undefined;
    [key: string]: any;
};
type AsyncStorageWithOptions<O> = {
    clear?: () => Promise<void> | void;
    getItem: (key: string, options?: O) => Promise<string | null> | string | null;
    getAll?: () => Promise<any>;
    setItem: (key: string, value: string, options?: O) => Promise<void> | void;
    removeItem: (key: string) => Promise<void> | void;
    key: (index: number) => Promise<string | null> | string | null;
    readonly length: Promise<number> | number | undefined;
    [key: string]: any;
};
type AsyncStorageObject<T> = Record<string, Promise<T | null>>;
type AsyncStorageSetter<T, O> = (key: string, value: T, options?: O) => Promise<void> | void;
type AsyncStorageActions<T> = {
    remove: (key: string) => Promise<void> | void;
    clear: () => Promise<void> | void;
    error: () => Error | undefined;
    toJSON: () => Promise<{
        [key: string]: T;
    }>;
};
type StorageSignalProps<T, A, O> = StorageProps<T, A, O> & {
    /** signal equality checker */
    equals?: false | ((prev: T, next: T) => boolean);
    /** signal name used in dev mode */
    name?: string;
    internal?: boolean;
    /** should the storage be synchronized via Storage events, default is `true`? */
    sync?: boolean;
    /** errors will be thrown and need to be caught in an ErrorBoundary, default is `false` */
    throw?: boolean;
};

/**
 * like createStore, but bound to a localStorage-like API
 * ```typescript
 * type StorageWithOptions<O> = Storage; // but with options added to setItem
 * type StorageProps<T extends string, O> = {
 *   api?: Storage | StorageWithOptions;
 *   // or an array thereof, default will be localStorage
 *   deserializer?: (value: string, key: string, options?: O) => T;
 *   serializer?: (value: T, key: string, options?: O) => string;
 *   options?: O; // options
 *   prefix?: string // will be prefixed to the key
 * };
 * createStorage(props?: StorageProps) => [
 *   store: StorageObject<T>, // basically like `Store<T>`
 *   setter: StorageSetter<T>, // like `setStoreFunction<T>`
 *   actions: {
 *     remove: (key: string) => void;
 *     clear: () => void;
 *     toJSON: () => { [key: string]: T };
 *   }
 * ]
 * ```
 * @deprecated in favor of makePersisted
 */
declare function createStorage<O>(props?: StringStorageProps<Storage | StorageWithOptions<O>, O>): [
    store: StorageObject<string>,
    setter: StorageSetter<string, O>,
    actions: StorageActions<string>
];
declare function createStorage<O, T>(props?: AnyStorageProps<Storage | StorageWithOptions<O>, O, T>): [store: StorageObject<T>, setter: StorageSetter<T, O>, actions: StorageActions<T>];
/**
 * like createStore, but bound to an asynchronous localStorage-like API
 * ```typescript
 * type AsyncStorage = Storage // but returns everything wrapped in Promises
 * type AsyncStorageWithOptions<O> = Storage; // but with options added to setItem
 * type AsyncStorageProps<T extends string, O> = {
 *   api?: AsyncStorage | AsyncStorageWithOptions;
 *   // or an array thereof, default will be localStorage
 *   deserializer?: (value: string, key: string, options?: O) => T;
 *   serializer?: (value: T, key: string, options?: O) => string;
 *   options?: O; // options
 *   prefix?: string // will be prefixed to the key
 * };
 * createStorage(props?: AsyncStorageProps) => [
 *   store: AsyncStorageObject<T>, // basically like `Store<T>`
 *   setter: AsyncStorageSetter<T>, // like `setStoreFunction<T>`
 *   actions: {
 *     remove: (key: string) => Promise<void>;
 *     clear: () => Promise<void>;
 *     toJSON: () => Promise<{ [key: string]: T }>;
 *   }
 * ]
 * ```
 * @deprecated in favor of makePersisted
 */
declare function createAsyncStorage<O>(props?: StringStorageProps<AsyncStorage | AsyncStorageWithOptions<O>, O>): [
    store: AsyncStorageObject<string>,
    setter: AsyncStorageSetter<string, O>,
    actions: AsyncStorageActions<string>
];
declare function createAsyncStorage<O, T>(props?: AnyStorageProps<T, AsyncStorage | AsyncStorageWithOptions<O>, O>): [
    store: AsyncStorageObject<T>,
    setter: AsyncStorageSetter<T, O>,
    actions: AsyncStorageActions<T>
];
/**
 * like createSignal, but bound to a localStorage-like API
 * ```typescript
 * type StorageWithOptions<O> = Storage; // but with options added to setItem
 * type StorageProps<T extends string, O> = {
 *   api?: Storage | StorageWithOptions;
 *   // or an array thereof, default will be localStorage
 *   deserializer?: (value: string, key: string, options?: O) => T;
 *   serializer?: (value: T, key: string, options?: O) => string;
 *   options?: O; // options
 *   prefix?: string // will be prefixed to the key
 * };
 * createStorage<T extends string>(key: string, props?: StorageProps<T>) => [
 *   accessor: Accessor<T> &
 *     { error: () => Error | undefined },
 *     // basically like `value()`
 *   setter: Setter<T>, // like `setValue()`
 *   refetch: () => void // reloads from storage
 * ]
 * ```
 * @deprecated in favor of makePersisted
 */
declare function createStorageSignal<T, O = {}>(key: string, initialValue?: T, props?: StorageSignalProps<T, Storage | StorageWithOptions<O>, O>): [accessor: Accessor<T | null>, setter: Setter<T | null>, refetch: () => void];
/** @deprecated in favor of makePersistent */
declare const createLocalStorage: typeof createStorage;
/** @deprecated in favor of makePersistent */
declare const createSessionStorage: <T, O = {}>(props: StorageProps<T, Storage, O>) => [store: StorageObject<string>, setter: StorageSetter<string, unknown>, actions: StorageActions<string>];

type CookieOptions = CookieProperties & {
    getRequest?: (() => Request) | (() => PageEvent);
    setCookie?: (key: string, value: string, options: CookieOptions) => void;
};
type CookieProperties = {
    domain?: string;
    expires?: Date | number | String;
    path?: string;
    secure?: boolean;
    httpOnly?: boolean;
    maxAge?: number;
    sameSite?: "None" | "Lax" | "Strict";
};
/**
 * handle cookies exactly like you would handle localStorage
 *
 * the main change is that setItem accepts the following options:
 * ```typescript
 * export type CookieOptions = {
 *   domain?: string;
 *   expires?: Date | number | String;
 *   path?: string;
 *   secure?: boolean;
 *   httpOnly?: boolean;
 *   maxAge?: number;
 *   sameSite?: "None" | "Lax" | "Strict";
 *   getRequest?: () => Request | () => PageEvent // useRequest from solid-start, vite users must pass the "useRequest" from "solid-start/server" function manually
 *   setCookie?: (key, value, options) => void // set cookie on the server
 * };
 * ```
 * Also, you can use its _read and _write properties to change reading and writing
 */
declare const cookieStorage: StorageWithOptions<CookieOptions>;
/**
 * creates a reactive store but bound to document.cookie
 * @deprecated in favor of makePersisted
 */
declare const createCookieStorage: <T, O = CookieOptions, A = StorageWithOptions<CookieOptions>>(props?: Omit<StorageProps<T, A, O>, "api"> | undefined) => [store: StorageObject<T>, setter: StorageSetter<T, O>, actions: StorageActions<T>];

/**
 * adds a `.clear` method to a Storage without one only using `.key`/`.removeItem`
 */
declare const addClearMethod: <S extends Storage | StorageWithOptions<any>>(storage: Omit<S, "clear"> & {
    clear?: (() => void) | undefined;
}) => S;

type PersistenceBaseOptions<T> = {
    name?: string;
    serialize?: (data: T) => string;
    deserialize?: (data: string) => T;
};
type PersistenceOptions<T, O extends Record<string, any>> = PersistenceBaseOptions<T> & ({
    storage: StorageWithOptions<O> | AsyncStorageWithOptions<O>;
    storageOptions: O;
} | {
    storage?: Storage | AsyncStorage;
});
/**
 * Persists a signal, store or similar API
 *  ```ts
 *  const [getter, setter] = makePersisted(createSignal("data"), options);
 *  const options = {
 *    storage: cookieStorage,  // can be any synchronous or asynchronous storage
 *    storageOptions: { ... }, // for storages with options, otherwise not needed
 *    name: "solid-data",      // optional
 *    serialize: (value: string) => value, // optional
 *    deserialize: (data: string) => data, // optional
 *  };
 *  ```
 *  Can be used with `createSignal` or `createStore`. The initial value from the storage will overwrite the initial
 *  value of the signal or store unless overwritten. Overwriting a signal with `null` or `undefined` will remove the
 *  item from the storage.
 *
 * @param {Signal<T> | [get: Store<T>, set: SetStoreFunction<T>]} signal - The signal or store to be persisted.
 * @param {PersistenceOptions<T, O>} options - The options for persistence.
 * @returns {Signal<T> | [get: Store<T>, set: SetStoreFunction<T>]} - The persisted signal or store.
 */
declare function makePersisted<T>(signal: [Accessor<T>, Setter<T>], options?: PersistenceOptions<T, {}>): [Accessor<T>, Setter<T>];
/**
 * Persists a signal, store or similar API
 *  ```ts
 *  const [getter, setter] = makePersisted(createSignal("data"), options);
 *  const options = {
 *    storage: cookieStorage,  // can be any synchronous or asynchronous storage
 *    storageOptions: { ... }, // for storages with options, otherwise not needed
 *    name: "solid-data",      // optional
 *    serialize: (value: string) => value, // optional
 *    deserialize: (data: string) => data, // optional
 *  };
 *  ```
 *  Can be used with `createSignal` or `createStore`. The initial value from the storage will overwrite the initial
 *  value of the signal or store unless overwritten. Overwriting a signal with `null` or `undefined` will remove the
 *  item from the storage.
 *
 * @param {Signal<T> | [get: Store<T>, set: SetStoreFunction<T>]} signal - The signal or store to be persisted.
 * @param {PersistenceOptions<T, O>} options - The options for persistence.
 * @returns {Signal<T> | [get: Store<T>, set: SetStoreFunction<T>]} - The persisted signal or store.
 */
declare function makePersisted<T, O extends Record<string, any>>(signal: Signal<T>, options: PersistenceOptions<T, O>): Signal<T>;
/**
 * Persists a signal, store or similar API
 *  ```ts
 *  const [getter, setter] = makePersisted(createSignal("data"), options);
 *  const options = {
 *    storage: cookieStorage,  // can be any synchronous or asynchronous storage
 *    storageOptions: { ... }, // for storages with options, otherwise not needed
 *    name: "solid-data",      // optional
 *    serialize: (value: string) => value, // optional
 *    deserialize: (data: string) => data, // optional
 *  };
 *  ```
 *  Can be used with `createSignal` or `createStore`. The initial value from the storage will overwrite the initial
 *  value of the signal or store unless overwritten. Overwriting a signal with `null` or `undefined` will remove the
 *  item from the storage.
 *
 * @param {Signal<T> | [get: Store<T>, set: SetStoreFunction<T>]} signal - The signal or store to be persisted.
 * @param {PersistenceOptions<T, O>} options - The options for persistence.
 * @returns {Signal<T> | [get: Store<T>, set: SetStoreFunction<T>]} - The persisted signal or store.
 */
declare function makePersisted<T>(signal: [get: Store<T>, set: SetStoreFunction<T>], options?: PersistenceOptions<T, {}>): [get: Store<T>, set: SetStoreFunction<T>];
/**
 * Persists a signal, store or similar API
 *  ```ts
 *  const [getter, setter] = makePersisted(createSignal("data"), options);
 *  const options = {
 *    storage: cookieStorage,  // can be any synchronous or asynchronous storage
 *    storageOptions: { ... }, // for storages with options, otherwise not needed
 *    name: "solid-data",      // optional
 *    serialize: (value: string) => value, // optional
 *    deserialize: (data: string) => data, // optional
 *  };
 *  ```
 *  Can be used with `createSignal` or `createStore`. The initial value from the storage will overwrite the initial
 *  value of the signal or store unless overwritten. Overwriting a signal with `null` or `undefined` will remove the
 *  item from the storage.
 *
 * @param {Signal<T> | [get: Store<T>, set: SetStoreFunction<T>]} signal - The signal or store to be persisted.
 * @param {PersistenceOptions<T, O>} options - The options for persistence.
 * @returns {Signal<T> | [get: Store<T>, set: SetStoreFunction<T>]} - The persisted signal or store.
 */
declare function makePersisted<T, O extends Record<string, any>>(signal: [get: Store<T>, set: SetStoreFunction<T>], options: PersistenceOptions<T, O>): [get: Store<T>, set: SetStoreFunction<T>];

export { AnyStorageProps, AsyncStorage, AsyncStorageObject, AsyncStorageSetter, AsyncStorageWithOptions, CookieOptions, PersistenceOptions, StorageDeserializer, StorageObject, StorageProps, StorageSerializer, StorageSetter, StorageSignalProps, StorageWithOptions, StringStorageProps, addClearMethod, cookieStorage, createAsyncStorage, createCookieStorage, createLocalStorage, createSessionStorage, createStorage, createStorageSignal, makePersisted };
